---
title: 스마트 컨트랙트
description:
keywords:
  - 스마트 컨트랙트 옵션
  - WebAssembly
  - Solidity
  - ink!
  - Wasm
---

[무엇을 구축할지 결정](../../build/decide-what-to-build.md)에서 논의된 대로, 스마트 컨트랙트는 Substrate 기반 블록체인에서 애플리케이션을 구축하는 한 가지 방법입니다.
스마트 컨트랙트에는 일정한 제한 사항이 있지만 이점도 있습니다.
예를 들어, 스마트 컨트랙트로 프로젝트를 시작하는 이유 중 하나는 계약을 빠르게 개발하고 테스트할 수 있어 설계 결정을 반복하고 애플리케이션을 빠르게 시장에 출시할 수 있다는 점입니다.

일반적으로 Substrate 런타임에 배포할 수 있는 두 가지 유형의 스마트 컨트랙트가 있습니다:

- WebAssembly 컨트랙트.
- EVM 호환 컨트랙트.

어떤 유형의 컨트랙트를 구축할지 결정하는 것은 첫 번째 결정 중 하나입니다.
또한 스마트 컨트랙트는 특정 체인 주소인 스마트 컨트랙트 계정 주소를 사용하여 인스턴스화되고 실행되는 명령어입니다.
이는 스마트 컨트랙트를 작성하는 데 사용할 언어를 선택하는 것 외에도 컨트랙트를 호스트 플랫폼으로 사용할 체인을 식별해야 한다는 것을 의미합니다.
예를 들어, 기존 ***인프라 블록체인(InfraBlockchain)*** 생태계의 파라체인에 스마트 컨트랙트으로 애플리케이션을 배포하거나, 원하는 유형의 컨트랙트를 배포하기 위해 특정 팀과 함께 사용자 정의 파라체인을 구축하거나, 특정 기능과 기능을 제공하는 자체 런타임을 구축할 수 있습니다.

## Contracts 팔레트에 대해

대부분의 경우, Contracts 팔레트는 Substrate 런타임에 스마트 컨트랙트를 구축하는 가장 좋은 옵션입니다.
Contracts 팔레트를 런타임에 추가함으로써 WebAssembly 기반 스마트 컨트랙트를 배포하고 실행할 수 있습니다.
스마트 컨트랙트를 호스트하기 위해 자체 런타임을 구축하는 경우 Contracts 팔레트를 포함하는 주요한 이유는 다음과 같습니다:
대부분의 경우, Contracts 팔레트는 Substrate 런타임에 스마트 컨트랙트를 구축하는 가장 좋은 옵션입니다.
Contracts 팔레트를 런타임에 추가함으로써 WebAssembly 기반 스마트 컨트랙트를 배포하고 실행할 수 있습니다.
스마트 컨트랙트를 호스트하기 위해 자체 런타임을 구축하는 경우 Contracts 팔레트를 포함하는 주요한 이유는 다음과 같습니다:

- 원하는 **핵심 기능**을 제공하기 위해 스마트 컨트랙트를 사용하는 일반적인 목적의 블록체인을 구축하려는 경우입니다.

  예를 들어, 스마트 컨트랙트를 중점으로 한 혁신적인 아이디어가 있다면 Contracts 팔레트를 사용하여 체인의 기본 레이어를 구축한 다음, 응용 프로그램 특정 목표를 달성하기 위해 필요한 최소한의 추가 팔레트만 추가할 수 있습니다.

- 스마트 컨트랙트를 사용하여 체인과 상호작용할 **유연성**을 갖춘 응용 프로그램별 블록체인을 구축하려는 경우입니다.

  예를 들어, 대부분의 로직이 다른 Substrate 팔레트를 사용하여 정의된 체인을 구축하고 있지만, 일부 체인 로직을 스마트 컨트랙트를 통해 사용자에게 노출시키고 싶을 수 있습니다.
  이러한 유형의 사용 사례에는 스마트 컨트랙트가 이상적입니다. 스마트 컨트랙트는 모든 사용자 입력을 신뢰할 수 없고 잠재적으로 적대적인 것으로 처리합니다.

  예를 들어, 탈중앙화 거래소를 구축한다고 가정해 봅시다.
  대부분의 로직은 팔레트에서 정의되지만, 사용자가 스마트 컨트랙트를 통해 자체 거래 알고리즘을 업로드할 수 있도록 하고 싶습니다.
  스마트 컨트랙트 실행에 따른 가스 수수료로 인해 사용자는 거래 알고리즘의 실행 시간에 대한 비용을 지불해야 합니다.

  Contracts 팔레트는 이러한 기능을 위한 [Chain extension](https://ink.substrate.io/macros-attributes/chain-extension/) 원시 기능을 제공하며, [ink!](https://paritytech.github.io/ink/)와 같은 프로그래밍 언어는 체인이 노출하는 비즈니스 로직 원시 기능을 활용할 수 있습니다.

## 스마트 컨트랙트 계정

Contracts 팔레트는 `Currency` 트레이트를 기반으로 계정에 스마트 컨트랙트 기능을 추가합니다.
이러한 **스마트 컨트랙트 계정**을 사용하여 스마트 컨트랙트를 인스턴스화하고 다른 컨트랙트 및 비컨트랙트 계정에 호출을 할 수 있습니다.

스마트 컨트랙트 코드는 캐시에 저장되며 해시를 사용하여 검색할 수 있습니다.
이 설계는 동일한 해시에서 여러 스마트 컨트랙트를 인스턴스화할 수 있도록 하고 코드를 반복해서 저장하지 않아도 되도록 합니다.

사용자가 스마트 컨트랙트와 상호작용하기 위해 함수 중 하나를 호출할 때, 관련된 스마트 컨트랙트 코드가 코드 해시를 사용하여 검색되고 함수가 실행됩니다.
스마트 컨트랙트 함수 호출은 다음과 같은 결과를 가져올 수 있습니다:

- 스마트 컨트랙트 계정과 관련된 스토리지 변경.
- 비계약 계정과 관련된 스토리지 변경.
- 새로운 스마트 컨트랙트 인스턴스화.
- 다른 스마트 컨트랙트 계정 호출.
- 스마트 컨트랙트 계정과 관련된 스토리지 변경.
- 비컨트랙트 계정과 관련된 스토리지 변경.
- 새로운 스마트 컨트랙트 인스턴스화.
- 다른 스마트 컨트랙트 계정 호출.

스마트 컨트랙트 계정이 고갈되면 관련된 코드와 스토리지도 삭제됩니다.

## 컨트랙트 실행과 가스

스마트 컨트랙트에 의해 호출되는 모든 명령어는 **가스** 수수료로 지불되어야 합니다.
송신자는 모든 호출에 대해 가스 한도를 지정해야 합니다.
사용되지 않은 가스는 호출 후에 환불되며, 실행 결과와 관계없이 환불됩니다.

가스 한도에 도달하면, 모든 호출 및 상태 변경(잔액 이체 포함)은 현재 호출의 컨트랙트 수준에서만 되돌립니다.
예를 들어, 컨트랙트 A가 컨트랙트 B를 호출하고 컨트랙트 B가 호출 중에 가스가 부족하면, 컨트랙트 B의 모든 호출과 상태 변경이 되돌아갑니다.
컨트랙트 A에 올바른 오류 처리가 있으면, 컨트랙트 A가 수행하는 다른 호출 및 상태 변경은 유지됩니다.
