---
title: 거래와 블록 기본 사항
description: 블록을 생성하는 데 사용되는 거래 유형과 블록의 기본 구성 요소에 대해 설명합니다.
keywords:
---

이 글에서는 생성할 수 있는 다양한 거래 유형과 런타임에서 이들을 어떻게 사용할 수 있는지에 대해 알아보게 될 것입니다.
일반적으로 거래는 블록체인의 블록에 포함될 데이터를 결정하는 메커니즘을 제공합니다.
다양한 거래 유형이 어떻게 사용되는지 학습함으로써, 필요에 맞는 적절한 유형을 선택하는 데 더 잘 준비될 수 있을 것입니다.

## 거래란 무엇인가요?

일반적으로 거래는 블록에 포함될 수 있는 상태 변경을 위한 메커니즘을 제공합니다.
Substrate에는 세 가지 구분된 거래 유형이 있습니다:

- [서명된 거래](#서명된-거래)
- [서명되지 않은 거래](#서명되지-않은-거래)
- [본질적인 거래](#본질적인-거래)

Substrate에서 이 세 가지 거래 유형은 종종 **외부 처리**라는 더 넓은 의미로 사용됩니다.
외부 처리는 일반적으로 런타임 외부에서 시작된 모든 정보를 의미하는 용어입니다.

그러나 실용적인 목적을 위해서는 각 거래 유형을 개별적으로 고려하고, 각 유형이 가장 적합한 경우를 식별하는 것이 더 유용합니다.

### 서명된 거래

서명된 거래는 런타임 호출을 실행하기 위해 수신한 요청을 보내는 계정의 서명을 포함해야 합니다.
일반적으로, 요청은 요청을 제출하는 계정의 개인 키를 사용하여 서명됩니다.
대부분의 경우, 요청을 제출하는 계정은 거래 수수료를 지불합니다. 그러나 거래 수수료와 거래 처리의 다른 요소는 런타임 로직이 어떻게 정의되었는지에 따라 달라집니다.

서명된 거래는 가장 일반적인 거래 유형입니다.
예를 들어, 일정 수의 토큰을 가진 계정이 있다고 가정해 봅시다.
토큰을 Alice에게 이전하려면 Balances 팔레트의 `pallet_balances::Call::transfer` 함수를 호출할 수 있습니다.
이 호출을 수행하기 위해 사용되는 계정이 당신의 계정이므로, 거래에 서명하기 위해 당신의 계정 키가 사용됩니다.
요청자로서, 요청이 처리되기 위해 수수료를 지불하는 것이 일반적입니다.
선택적으로, 블록 작성자에게 팁을 주어 거래에 더 높은 우선순위를 부여할 수도 있습니다.

### 서명되지 않은 거래

서명되지 않은 거래는 서명을 필요로 하지 않으며, 거래를 제출한 사람에 대한 어떠한 정보도 포함하지 않습니다.

서명되지 않은 거래의 경우, 스팸이나 재생 공격을 방지할 경제적인 방해 요소가 없습니다.
서명되지 않은 거래를 유효성 검사하기 위한 조건과 네트워크의 오용과 공격으로부터 보호하기 위해 필요한 로직을 정의해야 합니다.
서명되지 않은 거래는 사용자 정의 유효성 검사를 필요로 하기 때문에, 이 유형의 거래는 서명된 거래보다 더 많은 리소스를 소비합니다.

`pallet_im_online::Call::heartbeat` 함수는 서명되지 않은 거래를 사용하여 유효성 검사자 노드가 네트워크에 온라인 상태임을 나타낼 수 있도록 합니다.
이 함수는 네트워크에 등록된 유효성 검사자 노드만이 호출할 수 있습니다.
이 함수에는 유효성 검사자인지를 확인하는 내부 로직이 포함되어 있어, 유효성 검사자인 노드는 수수료를 지불하지 않고 서명되지 않은 거래를 사용하여 이 함수를 호출할 수 있습니다.

### 본질적인 거래

본질적인 거래는 특수한 유형의 서명되지 않은 거래입니다.
이 유형의 거래를 사용하여 블록 작성 노드는 블록에 직접 정보를 추가할 수 있습니다.
본질적인 거래는 호출한 블록 작성 노드만이 블록에 삽입할 수 있습니다.
일반적으로, 이 유형의 거래는 다른 노드에게 전파되지 않거나 거래 큐에 저장되지 않습니다.
본질적인 거래를 사용하여 삽입된 데이터는 특정한 유효성 검사를 필요로 하지 않고 유효하다고 가정됩니다.

예를 들어, 블록 작성 노드가 블록에 타임스탬프를 삽입하는 경우, 타임스탬프가 정확한지 증명할 방법은 없습니다.
대신, 유효성 검사자는 블록이 자신의 시스템 클럭의 일정한 범위 내에 있는지 여부에 따라 블록을 수락하거나 거부할 수 있습니다.

예를 들어, `pallet_timestamp::Call::now` 함수는 블록 작성 노드가 각 블록에 현재 타임스탬프를 삽입할 수 있도록 합니다.
마찬가지로, `paras_inherent::Call::enter` 함수는 파라체인 콜레이터 노드가 릴레이 체인이 기대하는 유효성 검사 데이터를 릴레이 체인에 전송할 수 있도록 합니다.

## 블록이란 무엇인가요?

Substrate에서 블록은 헤더와 거래 배열로 구성됩니다.
헤더에는 다음과 같은 속성이 포함됩니다:

- 블록 높이
- 부모 해시
- 거래 루트
- 상태 루트
- 다이제스트

모든 거래는 런타임에서 정의된대로 실행되기 위해 하나의 시리즈로 묶여 있습니다.
거래 루트는 이 시리즈의 암호화된 다이제스트입니다.
이 암호화된 다이제스트는 두 가지 목적을 가지고 있습니다:

- 헤더가 구축되고 배포된 후 거래 시리즈에 대한 어떠한 변경도 방지합니다.
- 경량 클라이언트가 헤더의 정보만으로 주어진 거래가 블록에 존재하는지 간결하게 확인할 수 있게 합니다.

## 다음으로 어디로 가야 할까요

이제 거래 유형과 블록을 구성하는 정보에 대해 알게 되었으므로, 더 자세한 내용을 알아보기 위해 다음 주제를 탐색해 보세요.

- [거래 수명 주기](/learn/transaction-lifecycle/)
- [상태 전이와 저장소](/learn/state-transitions-and-storage/)
- [거래, 가중치, 수수료](/build/tx-weights-fees/)
- [거래 형식](/reference/transaction-format/)
- [블록 참조](https://paritytech.github.io/substrate/master/sp_runtime/traits/trait.Block.html)